---
layout: post
title: "Classes, Objetos e Traits em Scala"
categories:
  - scala
  - linguagem de programa√ß√£o
tags:
  - scala
  - jvm
  - spark
featured-img: scala
slug: scala-IV
translationKey: scala-IV
date: 2020-12-08T08:25:52-03:00
---

Esse artigo tamb√©m pode ser chamado ‚Äú*Minha saga aprendendo Scala - Parte 4*"

<!--more-->

- [Parte 1 - Minha saga aprendendo Scala](https://leportella.com/pt-br/scala-i/)
- [Parte 2 - Fun√ß√µes em String](https://leportella.com/pt-br/scala-ii/)
- [Parte 3 - Classes em Scala: m√©todos e defini√ß√µes de atributos](https://leportella.com/pt-br/scala-iii/)

**Novas sugest√µes!**

Bom... pelo menos uma pessoa tem lido esses artigos sobre Scala! O Bram Elfrink [me mandou um link sobre uma s√©rie de aulas de Scala dadas pelo Twitter](https://twitter.github.io/scala_school/) que parece muito bom! Vai l√° conferir! Obrigada, Bram!

## Objetos

[No √∫ltimo post](https://leportella.com/pt-br/scala-iII/), eu mostrei como trabalhar com atributos e m√©todos de classe, especialmente como limitar o uso deles. Mas classes s√£o apenas um tipo de objeto em Scala. Como discutimos na [Parte 2](https://leportella.com/pt-br/scala-ii/), quando voc√™ quer rodar algo em Scala, voc√™ cria um `object` n√£o uma classe.  Ent√£o qual a diferen√ßa entre um e outro?

Quando criamos uma nova classe (com `class`), podemos instanci√°-la, da seguinte forma:

```scala
class Pessoa(val nome: String) 
val maria = new Pessoa("Maria") 

```

{{<figure src="/assets/img/posts/scala-classes1.png#center">}}

Se eu criar uma nova pessoa, isso vai criar uma nova inst√¢ncia:

```scala
val joao = new Pessoa("Joao")

```

A inst√¢ncia `joao` n√£o √© a mesma que a inst√¢ncia `maria`, porque cada vez que chamamos `new Pessoa`, n√≥s criamos uma inst√¢ncia nova. 

{{<figure src="/assets/img/posts/scala-classes2.png#center">}}

Em Scala, um `object` sempre vai criar uma √∫nica inst√¢ncia, n√£o importa quantas vezes voc√™ a instancia. E √© por isso que o `object` √© chamado um *singleton*. 

{{<figure src="/assets/img/posts/scala-classes3.png#center">}}

Na verdade, nem precisamos da palavra `new` antes de uma instanciar um objeto, porque n√£o precisamos instanciar um objeto de forma alguma! Quando voc√™ cria um `object`, ele vai ser instantaneamente instanciado, ent√£o voc√™ pode simplesmente us√°-lo.

Por causa dessa caracter√≠stica, um `object` em Scala n√£o pode ter um construtor da mesma forma que uma classe, isto √©, n√£o pode receber nenhum par√¢metro. 

Nos exemplos a seguir voc√™ vai ver que ambos os valores `maria` e `joao` s√£o a mesma inst√¢ncia.

```scala
object Pessoa
val maria = Pessoa     // mesmo que `new Pessoa`
val joao = Pessoa      // mesmo que `new Pessoa`

println(maria == joao) // true

```

J√° que um `object` √© sempre uma inst√¢ncia - e apenas uma inst√¢ncia - voc√™ sempre pode acessar os atributos e m√©todos diretamente:

```scala
object Casa {
  val tem_cozinha: Boolean = true  
}

println(Casa.tem_cozinha) // true

```

Uma outra coisa interessante √© que voc√™ consegue criar, num mesmo arquivo, uma classe com o mesmo nome de um `object`.

O arquivo a seguir funciona perfeitamente:

```scala
object Pessoa {
  numero_de_olhos = 2
}

class Pessoa(nome: String)

val pessoa = Pessoa              // object
val maria = new Pessoa("Maria")  // class

```

## Overloading

No √∫ltimo artigo, eu mostrei como podemos criar uma classe com m√∫ltiplos construtores. N√≥s podemos simplesmente escrever dois construtores com diferentes par√¢metros. Essa funcionalidade se chama *overloading* e funciona tamb√©m para qualquer m√©todo que voc√™ queira: 

```scala
class Pessoa(nome: String) { 
    def cumprimentar(nome: String) = println(s"${this.nome} diz: Ol√°, $nome")
    // overloading
    def cumprimentar = println(s"Ol√°! Me chamo $nome")

val joao = new Pessoa("Joao")

println(joao.cumprimentar)           // Ol√°! Me chamo Joao
println(joao.cumprimentar("Maria"))  // Joao diz: Ol√°, Maria

```

## Abstra√ß√µes!

Agora vemos como classes e `object`s funciona, √© hora dee entender como usar abstra√ß√µes de objetos para serem herdadas em uma classe. [Uma das coisas que estimula o uso de heran√ßa de classes √© o conceito de reusabilidade](https://techdifferences.com/difference-between-single-and-multiple-inheritance.html), permitindo que classes reusem atributos e m√©todos que est√£o dispon√≠veis em outras classes, evitando duplica√ß√£o de c√≥digo!

### Classe a**bstrata**

Uma [classe abstrata](https://docs.scala-lang.org/overviews/scala-book/abstract-classes.html) √© uma classe como qualquer outra mas escrita com um `abstract` na frente da declara√ß√£o. Ela tamb√©m pode ter um construtor e receber par√¢metros (como qualquer classe) e ter m√©todos e atributos que podem ser sobrescritos:

```scala
abstract class Animal {
  val tipo: String
  def come: Unit
}

class Cachorro extends Animal {
  override val tipo: String = "Cachorro"
  override def come: Unit = ???
}

val animal = new Animal      // Erro! class Animal is abstract; cannot be instantiated
val cachorro = new Cachorro  // Works!

```

E voc√™ tamb√©m pode colocar um par√¢metro obrigat√≥rio na classe abstrata, adicionando um construtor dessa forma:

```scala
abstract class Animal(val identificacao: String)
class Cachorro(val nome: String) extends Animal(nome)

```

No entanto, tem um problema! Voc√™ s√≥ pode estender 1 classe abstrata em uma classe regular. Portanto, nossa classe `Cachorro` n√£o pode extender nenhuma outra classe al√©m de `Animal`. Essa restri√ß√£o da linguagem, de apenas permitir que uma classe herde de apenas uma outra classe, se chama *heran√ßa √∫nica* (*single inheritance*). Eu tentei entender por que uma linguagem permitiria apenas uma √∫nica heran√ßa e [eu achei uma explica√ß√£o para C#]() (livre tradu√ß√£o):

> C#  n√£o suporta heran√ßa m√∫ltipla porque ela adiciona muita complexidade ao C# enquanto prov√™ pouco benef√≠cio.

### **Traits**

No livro [Programming in Scala](https://www.artima.com/pins1ed/index.html#TOC) Primeira Edi√ß√£o, traits √© definido como (livre tradu√ß√£o):

> Traits s√£o uma unidade fundamental de reutiliza√ß√£o de c√≥digo em Scala. [1]

Semelhante √†s classes abstratas, os *traits* s√£o uma forma de reunir fun√ß√µes e m√©todos em um √∫nico lugar e reutiliz√°-los em outras classes. Voc√™ pode definir um *trait* da seguinte forma:

```scala
trait Carnivoro {
  def perseguirPresa: Unit
}

```

Mas, at√© onde eu pude ver, existem duas diferen√ßas principais entre *traits* e classes abstratas:

- *Traits* n√£o t√™m um construtor, ent√£o eles n√£o podem receber par√¢metros
- Uma √∫nica classe pode herdar v√°rios *traits*

Portanto, podemos ter coisas como:

```scala
trait Animal {
  val estaVivo: Boolean = true
}

trait Carnivoro {
  val tipo: String = "Carnivoro"
  def come(animal: String): String = s"${this.tipe} come $animal"
}

trait SangueFrio {
  val ambiente: String = "Calor"
}

class Crocodilo extends Animal with Carnivoro with SangueFrio {
  override val tipo: String = "Crocodilo"
}
class Cachorro extends Animal with Carnivoro {
  override val tipo: String = "Cachorro"
}

val cachorro = new Cachorro
val croc = new Crocodilo

println(croc.come(cachorro.tipo)) // Crocodilo come Cachorro

```

### Escolhendo entre uma classe abstrata e *trait*

Ok, Maravilha! E agora? Qual dos dois eu uso?

[Nosso amigo Stack Overflow tem uma longa explica√ß√£o sobre qual usar](). Mas o resumo √©: se n√£o tiver certeza, use *traits*. Em tradu√ß√£o livre:

> Se voc√™ n√£o tem certeza, mesmo considerando o que foi falado, comece criando um *trait*. Voc√™ sempre pode mudar de ideia depois, e em geral usar traits voc√™ deixa mais op√ß√µes abertas.

---

Por hoje √© s√≥! Demorei um pouco e n√£o sou estou t√£o conseguindo me concentrar tanto no curso de Scala. Houve um cap√≠tulo sobre *Generics* que acabou com a minha motiva√ß√£o, mas eu n√£o desisti! Com sorte, escreverei sobre isso um dia, mas quem sabe !? Nunca imaginei chegar √† Parte 4! üôÇ
