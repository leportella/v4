---
layout: post
title: "Classes em Scala: m√©todos e defini√ß√µes de atributos"
categories:
  - scala
  - linguagem de programa√ß√£o
tags:
  - scala
  - jvm
  - spark
featured-img: scala
slug: scala-III
translationKey: scala-III
date: 2020-11-20T11:25:52+00:00
---

Esse artigo tamb√©m pode ser chamado  "Minha saga aprendendo Scala - Parte 3" e √© a continua√ß√£o do artigo Minha saga aprendendo Scala - [Parte 1](https://leportella.com/pt-br/scala-i/) e [Parte 2](https://leportella.com/pt-br/scala-ii/).

<!--more-->

Como eu comentei na parte 1 dessa s√©rie, Scala √© uma linguagem de programa√ß√£o orientada a objetos. Da [Wikipedia](https://en.wikipedia.org/wiki/Object-oriented_programming) (livre tradu√ß√£o)

> A programa√ß√£o orientada a objetos (OOP) √© um paradigma de programa√ß√£o baseado no conceito de ‚Äúobjetos‚Äù, que podem conter dados, na forma de campos (muitas vezes conhecidos como atributos ou propriedades), e c√≥digo, na forma de procedimentos (muitas vezes conhecidos como m√©todos).

Neste artigo eu vou falar do que eu aprendi sobre classes de Scala, que segue o conceito de programa√ß√£o orientada a objetos que eu tirei da Wikipedia.

## Criando uma classe

Para criar uma classe, voc√™ s√≥ precisa passar a classe de palavra-chave e o nome da classe:

```scala
class Ponto    

val ponto = new Ponto
```

Os par√™nteses s√£o chamados de construtor de classe e voc√™ pode adicionar os atributos que sua classe pode receber, por exemplo:

```scala
class Ponto(x: Int, y: Int) 

val ponto = new Ponto(0, 0)
```

A parte legal come√ßa agora! Voc√™ pode reescrever o construtor para receber diferentes atributos, podendo receber mais ou menos atributos

```scala
class Pessoa(nome: String, idade: Int) {  
    def this(nome: String) = this(nome, 0)  
    def this() = this("Jo√£o", 0 )
}

val marco = new Pessoa("Marco", 30)
val bebeCarlos = new Pessoa("Carlos")
val joao = new Pesspa
```

## Adicionando atributos na classe

No exemplo acima, esses atributos que eu adicionei √† classe `Pessoa` n√£o podem ser acessados diretament como `marco.idade`.  Na realidade voc√™ tem 3 op√ß√µes para definir os atributos quando est√° criando o construtor de uma classe. N√£o passando nada (como o exemplo acima), com um `val` or um `var`.

Usando nada, os atributos s√£o privados e n√£o podem ser acessados:

```scala
class Ponto(x: Int)

val ponto = new Ponto(1)
ponto.x // erro!
```

Ao usar `val`, voc√™ pode acessar o atributo (voc√™ cria um *accessor*), mas n√£o pode alterar o valor (n√£o ter√° um *mutator*).

```scala
class Ponto(val x: Int)

val ponto = new Ponto(1)

ponto.x      // 1
ponto.x = 2  // won't work
```

Ent√£o adicionar um `val` na frente do atributo √© a mesma coisa que fazer isso:

```scala
class Ponto(xc: Int) {    
    def x = xc      // mesma coisa que   class Ponto(val x: Int)
}
```

Agora, se voc√™ usar `var`, voc√™ provavelmente j√° adivinhou: voc√™ ter√° um modificador e um acessador!

```scala
class Ponto(var x: Int)

val ponto = new Ponto(1)
println(ponto.x) // 1

ponto.x = 2 
println(ponto.x) // 2
```

Ent√£o voc√™ tem:

{{< table >}}
| **Defini√ß√£o de atributo** | **Acessador? (`point.x`)** | **Modificador? (`point.x = 4`)** | **Pode sobrescrever??** |
| ------------------------ | ----------------------- | -------------------------- | ----------------- |
| `val`                    | sim                     | n√£o                         | sim               |
| `var`                    | sim                     | sim                        | n√£o                |
| nada                   | n√£o                      | n√£o                         | sim               |
{{< /table >}}

## Usando classes

Ao definir uma classe, voc√™ pode usar outras palavras-chave extras para definir como voc√™ gostaria que sua classe se comportasse. At√© agora, aprendi tr√™s palavras-chave principais:

{{< table >}}
| **Palavras-chave**         | **Uso permitido**                                    |
| -------------------- | ---------------------------------------------------- |
| `class Ponto`        | Normal class that allows creating multiple instances |
| `final class Ponto`  | Doesn't allow class to be extended                   |
| `sealed class Ponto` | Allow class to be extended but only in the same file |
{{< /table >}}

{{< table >}} | **Palavras-chave** | **Uso Permitido** | | ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì | ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- | | `class Ponto` | Uma classe normal que permite a cria√ß√£o de m√∫ltiplas inst√¢ncias| | `final class Ponto` | A classe n√£o pode ser extendida | | `sealed class Ponto` | Permite que a classe seja estendida, mas apenas no mesmo arquiv | {{< /table >}}

## M√©todos de classes

Como as classes possuem palavras-chave que nos permitem alterar a forma como s√£o utilizadas, √© razo√°vel supor que tamb√©m existam palavras-chave que podem alterar o comportamento delas. Criei uma pequena tabela com as propriedades de cada um e exemplos para nos ajudar a entender o que muda exatamente.

*Obs: vou chamar de classe extendida a classe que herda (ou extende) da classe que estamos referenciado. Por exemplo, em `class Pessoa extends Humano`, a classe que estamos nos referindo √© `Humano` enquanto que a classe extendida √© `Pessoa`.*

{{< table >}}
|   |                                  | Classe extendidas pode usar? | Classes extendidas podem sobrescrever? | Inst√¢ncias das classes extendidas podem usar? |
| - | -------------------------------- | ----------------------- | ------------------------------ | ----------------------------------------------- |
| 1 | `def` / `val`                    | Sim                     | Sim                            | Sim                                             |
| 2 | `private def` / `private val`    | N√£o                      | N√£o precisam                  | N√£o                                              |
| 3 | `protected def`/ `protected val` | Sim                     | Sim                            | N√£o                                              |
| 4 | `final def` / `final val`        | Sim                     | N√£o                             | Sim                                             |
{{< /table >}}

## Caso 1: `def` e `val`

```scala
class Pessoa {  
    val atributo = 1  
    def metodo = s"caso $atributo"
}

class Leticia extends Pessoa

val leticia = new Leticia
println(leticia.atributo)       // 1
println(leticia.metodo)         // caso 1
```

## Caso 2: `private def` e `private val`

```scala
class Pessoa {  
    private val atributoPrivado = 2  
    private def metodoPrivado = s"caso $atributoPrivado"
}

class Leticia extends Person

val leticia = new Leticia
println(leticia.atributoPrivado)  // erro
println(leticia.metodoPrivado)    // erro
```

## Caso 3: `protected def` e `protected val`

```scala
class Pessoa {     
    protected val atributoProtegido = 3     
    protected def metodoProtegigo = s"caso $atributoProtegido" 
}  

class Gabi extends Pessoa 

val gabi = new Gabi 
println(gabi.metodoProtegigo)      //erro

class Leticia extends Pessoa {    
    override val atributoProtegido = super.atributoProtegido    
    override def metodoProtegigo = super.metodoProtegigo 
} 

val leticia = new Leticia 
println(leticia.metodoProtegigo)   // caso 3 
```

## Caso 4: `final def` e `final val`

```scala
class Pessoa {  
    final val atributoFinal = 4  
    final def metodoFinal = s"caso $atributoFinal"
}

class Leticia extends Pessoa {  
    override val atributoFinal = super.atributoFinal // erro
}

class Marco extends Pessoa

val marco = new Marco
println(marco.metodoFinal)      // caso 4
```

---

J√° que eu queria que este post fosse mais um cola do que um texto pesado ... √© isso por enquanto üôÇ Vejo voc√™ na Parte 4 (talvez?)!
